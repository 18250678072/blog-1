# 在前端中如何更好地优化打包资源

在前端中但凡谈到打包，肯定要提及到 `webpack`，毕竟它现在已经是最为流行的打包工具。但 `webpack` 更多地是表现在 `术` 上，于是我决定写这篇文章，更多地讲解一些关于 `道` 的。

对于一个前端而言，生产环境的静态资源优化，它既是面试中的高频问题，同时也最容易成为平时工作中的 OKR/KPI。如果你经常致力于优化前端打包提及，必然会对一些数字极为敏感，比如：

1. `lodash` 和 `react` gzip 后的体积是多少 (定性，可以给出范围)
1. 打包 `moment` 时会有什么问题
1. 你们线上前端项目首屏静态资源 gzip 后的体积是多少

如果你负责了你们前端项目的打包优化，如果以上问题连一个都不了解那么是说不通的。以我作为面试官的两年经验中，如果候选人对这些问题有所了解的话，往往对打包以及webpack的了解就会相对深入一些

## 原则

一般谈到打包会有两方面的意思，第一在于提高打包的速度，第二在于对打包后的静态资源的优化。**而对于静态资源的优化又不仅仅是打包提及的缩减。**

对于打包资源优化的总体原则，在于尽可能的减少或者延迟模块的引用。主要遵循以下三点

1. 减小打包的整体体积
1. 按需加载，优化页面首次加载体积。如根据路由按需加载，根据是否可见按需加载
1. 分包，根据模块更改频率分层次打包，充分利用缓存

接下来本篇文章将会结合实例分别阐述这三点

## 打包模块分析与数据

## 01 减小打包的整体体积

第一种方法是减小打包的整体体积。减小打包的总体积有多种方式，这往往也是打包资源优化的着力点，一方面操作性高易于实践，~另一方面有具体数据支撑易于写PPT来晋升~。我从网站性能优化的实践角度，来分为以下几个方面

### 移除不必要的模块

这句话好像是废话，但它却是真正有用并且极为容易修复的一点。

在以下代码中，对 `lodash` 这个模块进行了引入，但在之后的代码中并无使用 `lodash`，那在 webpack 中这个模块还会继续打包吗？

很遗憾，仍会对它进行打包。但好消息是这一点优化起来相当简单。

``` js
// 仅仅引入而未在代码中使用，该模块仍然会被打包
import _ from 'lodash'
```

对于这类问题总应该防患于未然，扼杀于摇篮中。`eslint` 的用武之地来了，它除了统一团队的代码风格以外，也用来提高团队的代码质量以及性能。

### 选择可替代的体积较小的模块

针对这一条，有一个典型的例子是以体积过大而臭名昭著的 `moment.js` 模块，它仅仅用于 `DateTime` 的格式化及各种计算。但你 `import` 之后它的体积竟然达到了 200kb+，gzip 后仍然有 69kb。以至于在 github 上有一个仓库专门用来介绍如何优化它，

+ [How to optimize moment.js with webpack](https://github.com/jmblog/how-to-optimize-momentjs-with-webpack)

再来一张图感受一下它巨大的体积吧：

![](https://raw.githubusercontent.com/jmblog/how-to-optimize-momentjs-with-webpack/master/source-map-explorer.png)

此时可以选择一个可替代它功能，但体积更小的模块。与 `moment.js` API 兼容的 `day.js`，它 gzip 后体积仅仅只有 2kb。

### 按需引入模块

当你面对一个巨无霸的，捆绑式的大型模块时，可能你并不会使用到它的所有的功能，你只需要按照你的需求引入模块就可以了。那经常会有哪些巨无霸模块呢？

如 `lodash` (勉强算)，`antd`，`echarts`，我相信这三个模块对于以 React 为主的前端工程师都或多或少使用过。对你所需要使用的模块单独引入：

``` js
import DatePicker from 'antd/es/date-picker'; // for js
import 'antd/es/date-picker/style/css'; // for css

import get from 'lodash.get'
```

## 02 按需加载，优化页面首次加载体积

## 03

